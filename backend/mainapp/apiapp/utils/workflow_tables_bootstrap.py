import json


def build_workflow_tables_bootstrap(inputs_config, outputs_config, tz_name) -> str:
    """Return python preamble that defines <Type>InputsTable / <Type>OutputsTable.

    This is prepended to generated workflow .py exports so notebooks can use:
        WELLInputsTable['Gas Rate'].Row['A1'].Sample[i].Value
        WELLInputsTable['Gas Rate'].Row['A1'].Sample[i].TimeOfSample

    Outputs support:
        WELLOutputsTable['Gas Rate'].Row['A1'].Value = 123
        WELLOutputsTable['Gas Rate'].Row['A1'].Save(123, date_time=..., description=...)
    """

    inputs_json = json.dumps(inputs_config or {}, ensure_ascii=False)
    outputs_json = json.dumps(outputs_config or {}, ensure_ascii=False)

    return "\n".join(
        [
            "# --- ProdCast workflow tables bootstrap (auto-generated) ---",
            "import json as __json",
            "from datetime import datetime, timedelta",
            "from zoneinfo import ZoneInfo",
            f"__wf_tz = ZoneInfo({tz_name!r})",
            "",
            f"__wf_inputs_cfg = __json.loads(r'''{inputs_json}''')",
            f"__wf_outputs_cfg = __json.loads(r'''{outputs_json}''')",
            "",
            "try:",
            "    internal",
            "except NameError:",
            "    internal = None",
            "",
            "try:",
            "    workflow_save_output",
            "except NameError:",
            "    workflow_save_output = None",
            "",
            "def __wf_ident(name):",
            "    s = ''.join(ch for ch in str(name) if ch.isalnum() or ch == '_')",
            "    if not s:",
            "        return '_Table'",
            "    if s[0].isdigit():",
            "        s = '_' + s",
            "    return s",
            "",
            "class _WF_Sample:",
            "    def __init__(self, value=None, time=None):",
            "        self.Value = value",
            "        self.TimeOfSample = time",
            "",
            "class _WF_SampleList:",
            "    def __init__(self, samples):",
            "        self._samples = list(samples or [])",
            "    def __getitem__(self, idx):",
            "        return self._samples[idx]",
            "    def __len__(self):",
            "        return len(self._samples)",
            "    def __iter__(self):",
            "        return iter(self._samples)",
            "",
            "class _WF_InputRowBinding:",
            "    def __init__(self, samples):",
            "        self.Sample = _WF_SampleList(samples)",
            "",
            "class _WF_InputRowCollection:",
            "    def __init__(self, row_map):",
            "        self._row_map = row_map or {}",
            "    def __getitem__(self, row_name):",
            "        if row_name not in self._row_map:",
            "            raise KeyError(row_name)",
            "        return _WF_InputRowBinding(self._row_map[row_name])",
            "",
            "class _WF_InputColumn:",
            "    def __init__(self, row_map):",
            "        self.Row = _WF_InputRowCollection(row_map)",
            "",
            "class _WF_InputsTable:",
            "    def __init__(self, columns):",
            "        self._columns = columns or {}",
            "    def __getitem__(self, col_name):",
            "        if col_name not in self._columns:",
            "            raise KeyError(col_name)",
            "        return self._columns[col_name]",
            "",
            "def __wf_build_inputs_table(tab):",
            "    if internal is None:",
            "        return _WF_InputsTable({})",
            "",
            "    object_type = tab.get('type') or None",
            "    instances = tab.get('instances') or []",
            "    cols_cfg = tab.get('columns') or []",
            "",
            "    component_ids = sorted({int(c.get('componentId')) for c in cols_cfg if c.get('componentId') is not None})",
            "    properties = sorted({str(c.get('property')) for c in cols_cfg if c.get('property')})",
            "",
            "    q_components = component_ids or None",
            "    q_instances = instances or None",
            "    q_properties = properties or None",
            "",
            "    records = internal.get_records(",
            "        components=q_components,",
            "        object_type=object_type,",
            "        instances=q_instances,",
            "        properties=q_properties,",
            "    )",
            "",
            "    key_to_record_id = {}",
            "    for r in (records or []):",
            "        comp_id = int(r.get('component_id') or r.get('component') or 0)",
            "        inst_name = r.get('object_instance__object_instance_name')",
            "        prop_name = r.get('object_type_property__object_type_property_name')",
            "        rid = r.get('data_set_id')",
            "        if not (comp_id and inst_name and prop_name and rid):",
            "            continue",
            "        key_to_record_id[(comp_id, str(inst_name), str(prop_name))] = rid",
            "    record_id_to_key = {rid: key for (key, rid) in key_to_record_id.items()}",
            "",
            "    dr = tab.get('dateRange') or {}",
            "    preset = dr.get('preset') or 'current'",
            "    start = None",
            "    end = None",
            "    if preset == 'custom':",
            "        start = dr.get('start') or None",
            "        end = dr.get('end') or None",
            "    elif preset == 'last_n':",
            "        try:",
            "            n = int(dr.get('value') or 1)",
            "        except Exception:",
            "            n = 1",
            "        unit = dr.get('unit') or 'week'",
            "        mul = 1 if unit == 'day' else (7 if unit == 'week' else 30)",
            "        now = datetime.now(__wf_tz)",
            "        end = now.isoformat()",
            "        start = (now - timedelta(days=mul * max(n, 1))).isoformat()",
            "",
            "    # Build current samples from MainClass records",
            "    current_samples = {}  # (comp_id, inst_name, prop_name) -> _WF_Sample",
            "    for r in (records or []):",
            "        comp_id = int(r.get('component_id') or r.get('component') or 0)",
            "        inst_name = r.get('object_instance__object_instance_name')",
            "        prop_name = r.get('object_type_property__object_type_property_name')",
            "        if not (comp_id and inst_name and prop_name):",
            "            continue",
            "        current_samples[(comp_id, str(inst_name), str(prop_name))] = _WF_Sample(r.get('value'), r.get('date_time'))",
            "",
            "    history = []",
            "    if preset != 'current':",
            "        history = internal.get_history(",
            "            components=q_components,",
            "            object_type=object_type,",
            "            instances=q_instances,",
            "            properties=q_properties,",
            "            start=start,",
            "            end=end,",
            "        )",
            "",
            "    table_data = {}  # {column_label: {row_name: [samples...]}}",
            "    for c in cols_cfg:",
            "        label = str(c.get('label') or c.get('property') or 'Column')",
            "        table_data.setdefault(label, {})",
            "",
            "    if instances:",
            "        for label in table_data:",
            "            for inst in instances:",
            "                table_data[label].setdefault(str(inst), [])",
            "",
            "    if history:",
            "        for h in history:",
            "            rid = h.get('main_record_id')",
            "            key = record_id_to_key.get(rid)",
            "            if not key:",
            "                continue",
            "            comp_id, inst_name, prop_name = key",
            "            for c in cols_cfg:",
            "                if int(c.get('componentId') or 0) != comp_id:",
            "                    continue",
            "                if str(c.get('property') or '') != str(prop_name):",
            "                    continue",
            "                label = str(c.get('label') or c.get('property') or 'Column')",
            "                table_data.setdefault(label, {})",
            "                table_data[label].setdefault(str(inst_name), []).append(_WF_Sample(h.get('value'), h.get('time')))",
            "",
            "",
            "    # Fill from current (MainClass) when requested / missing",
            "    if preset == 'current':",
            "        for (comp_id, inst_name, prop_name), sample in current_samples.items():",
            "            for c in cols_cfg:",
            "                if int(c.get('componentId') or 0) != comp_id:",
            "                    continue",
            "                if str(c.get('property') or '') != str(prop_name):",
            "                    continue",
            "                label = str(c.get('label') or c.get('property') or 'Column')",
            "                table_data.setdefault(label, {})",
            "                table_data[label].setdefault(str(inst_name), []).append(sample)",
            "    else:",
            "        # If history has no samples for a series, fall back to current",
            "        for (comp_id, inst_name, prop_name), sample in current_samples.items():",
            "            for c in cols_cfg:",
            "                if int(c.get('componentId') or 0) != comp_id:",
            "                    continue",
            "                if str(c.get('property') or '') != str(prop_name):",
            "                    continue",
            "                label = str(c.get('label') or c.get('property') or 'Column')",
            "                table_data.setdefault(label, {})",
            "                lst = table_data[label].setdefault(str(inst_name), [])",
            "                if not lst:",
            "                    lst.append(sample)",
            "",
            "    for _label, rows in table_data.items():",
            "        for _row, samples in rows.items():",
            "            try:",
            "                samples.sort(key=lambda s: s.TimeOfSample or '')",
            "            except Exception:",
            "                pass",
            "",
            "    columns = {label: _WF_InputColumn(rows) for (label, rows) in table_data.items()}",
            "    return _WF_InputsTable(columns)",
            "",            "class _WF_OutputSample:",
            "    def __init__(self, save_fn):",
            "        self._save_fn = save_fn",
            "        self._value = None",
            "        self.TimeOfSample = None",
            "    @property",
            "    def Value(self):",
            "        return self._value",
            "    @Value.setter",
            "    def Value(self, v):",
            "        self._value = v",
            "        self._save_fn(v, date_time=self.TimeOfSample)",
            "",
            "class _WF_OutputSampleList:",
            "    def __init__(self, save_fn):",
            "        self._save_fn = save_fn",
            "        self._samples = []",
            "    def __getitem__(self, idx):",
            "        try:",
            "            i = int(idx)",
            "        except Exception:",
            "            i = 0",
            "        while len(self._samples) <= i:",
            "            self._samples.append(_WF_OutputSample(self._save_fn))",
            "        return self._samples[i]",
            "    def append(self, item=None, *, value=None, time=None, date_time=None, description=None):",
            "        dt = date_time if date_time is not None else time",
            "        s = _WF_OutputSample(self._save_fn)",
            "        if dt is not None:",
            "            s.TimeOfSample = dt",
            "        if item is not None and value is None:",
            "            if isinstance(item, dict):",
            "                v = item.get(\"Value\") if \"Value\" in item else item.get(\"value\")",
            "                td = item.get(\"TimeOfSample\") if \"TimeOfSample\" in item else item.get(\"time\")",
            "                if td is not None:",
            "                    s.TimeOfSample = td",
            "                if v is not None:",
            "                    self._save_fn(v, date_time=s.TimeOfSample, description=description)",
            "            else:",
            "                self._save_fn(item, date_time=s.TimeOfSample, description=description)",
            "        elif value is not None:",
            "            self._save_fn(value, date_time=s.TimeOfSample, description=description)",
            "        self._samples.append(s)",
            "        return s",
            "    def __len__(self):",
            "        return len(self._samples)",
            "    def __iter__(self):",
            "        return iter(self._samples)",
            "",
            "class _WF_OutputRowBinding:",
            "    def __init__(self, save_fn):",
            "        self._save_fn = save_fn",
            "        self.Sample = _WF_OutputSampleList(save_fn)",
            "    @property",
            "    def Value(self):",
            "        return None",
            "    @Value.setter",
            "    def Value(self, v):",
            "        self._save_fn(v)",
            "    def Save(self, value, date_time=None, description=None):",
            "        self._save_fn(value, date_time=date_time, description=description)",
            "",            "class _WF_OutputRowCollection:",
            "    def __init__(self, save_by_row):",
            "        self._save_by_row = save_by_row or {}",
            "        self._cache = {}",
            "    def __getitem__(self, row_name):",
            "        if row_name in self._cache:",
            "            return self._cache[row_name]",
            "        if row_name not in self._save_by_row:",
            "            raise KeyError(row_name)",
            "        b = _WF_OutputRowBinding(self._save_by_row[row_name])",
            "        self._cache[row_name] = b",
            "        return b",
            "",
            "",
            "class _WF_OutputColumn:",
            "    def __init__(self, save_by_row):",
            "        self.Row = _WF_OutputRowCollection(save_by_row)",
            "",
            "class _WF_OutputsTable:",
            "    def __init__(self, columns):",
            "        self._columns = columns or {}",
            "    def __getitem__(self, col_name):",
            "        if col_name not in self._columns:",
            "            raise KeyError(col_name)",
            "        return self._columns[col_name]",
            "",
            "def __wf_output_save_to_value(cfg):",
            "    v = (cfg or {}).get('saveTarget')",
            "    return 'db' if v == 'db' else None",
            "",
            "def __wf_build_outputs_table(tab, outputs_cfg):",
            "    mode = (outputs_cfg or {}).get('mode') or 'append'",
            "    save_to = __wf_output_save_to_value(outputs_cfg)",
            "",
            "    object_type = tab.get('type') or None",
            "    instances = tab.get('instances') or []",
            "    cols_cfg = tab.get('columns') or []",
            "",
            "    def make_save(component_id, instance_name, property_name):",
            "        def _save(value, date_time=None, description=None):",
            "            if workflow_save_output is None:",
            "                raise RuntimeError('workflow_save_output is not available in this runtime')",
            "            record = {",
            "                'component': int(component_id) if component_id is not None else None,",
            "                'object_type': object_type,",
            "                'object_instance': instance_name,",
            "                'object_type_property': property_name,",
            "                'value': value,",
            "                'date_time': date_time,",
            "                'description': description,",
            "            }",
            "            workflow_save_output([record], mode=mode, save_to=save_to, component_id=int(component_id) if component_id is not None else None)",
            "        return _save",
            "",
            "    columns = {}",
            "    for c in cols_cfg:",
            "        label = str(c.get('label') or c.get('property') or 'Column')",
            "        component_id = c.get('componentId')",
            "        prop = c.get('property')",
            "        save_by_row = {}",
            "        for inst in (instances or []):",
            "            save_by_row[str(inst)] = make_save(component_id, str(inst), prop)",
            "        columns[label] = _WF_OutputColumn(save_by_row)",
            "",
            "    return _WF_OutputsTable(columns)",
            "",
            "for __tab in (__wf_inputs_cfg.get('tabs') or []):",
            "    __t = __tab.get('type') or 'Inputs'",
            "    __var = f\"{__wf_ident(__t)}InputsTable\"",
            "    globals()[__var] = __wf_build_inputs_table(__tab)",
            "",
            "for __tab in (__wf_outputs_cfg.get('tabs') or []):",
            "    __t = __tab.get('type') or 'Outputs'",
            "    __var = f\"{__wf_ident(__t)}OutputsTable\"",
            "    globals()[__var] = __wf_build_outputs_table(__tab, __wf_outputs_cfg)",
            "",
            "",
            "class _WF_ConfigView:",
            "    def __init__(self, cfg):",
            "        self._cfg = cfg or {}",
            "        self.tabs = list(self._cfg.get(\"tabs\") or [])",
            "        self.instances = {}  # type -> [instances...]",
            "        self.properties = {} # type -> [properties...]",
            "        self.columns = {}    # type -> [column labels...]",
            "        for tab in self.tabs:",
            "            t = tab.get(\"type\") or \"Default\"",
            "            inst = list(tab.get(\"instances\") or [])",
            "            cols = list(tab.get(\"columns\") or [])",
            "            props = [c.get(\"property\") for c in cols if c.get(\"property\")]",
            "            labels = [c.get(\"label\") for c in cols if c.get(\"label\")]",
            "            self.instances[t] = inst",
            "            self.properties[t] = props",
            "            self.columns[t] = labels",
            "",
            "inputs = _WF_ConfigView(__wf_inputs_cfg)",
            "outputs = _WF_ConfigView(__wf_outputs_cfg)",
            "",
            "# --- End bootstrap ---",
        ]
    )
